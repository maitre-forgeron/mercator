name: Publish Images

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  publish:
    if: >
      github.event.workflow_run.conclusion == 'success' &&
      (github.event.workflow_run.head_branch == 'master' || startsWith(github.event.workflow_run.head_branch, 'v'))
    runs-on: ubuntu-latest

    env:
      REGISTRY: ghcr.io
      OWNER: ${{ github.repository_owner }}
      IMAGE_REPO: mercator-bootstrapper
      FRONTEND_IMAGE_REPO: mercator-frontend-server
      APPHOST: src/Mercator.AppHost/Mercator.AppHost.csproj
      BOOTSTRAPPER_CSPROJ: src/Mercator.Bootstrapper/Mercator.Bootstrapper.csproj

    steps:
      - name: Checkout (same commit CI tested)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x
          include-prerelease: true

      - name: Install Aspire CLI
        run: dotnet tool install --global Aspire.Cli

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          SHA="${{ github.event.workflow_run.head_sha }}"
          SHORT_SHA="${SHA:0:7}"
          BRANCH="${{ github.event.workflow_run.head_branch }}"

          # Push tags
          PUSH_TAGS="sha-${SHORT_SHA}"
          DEPLOY_TAG="sha-${SHORT_SHA}"

          if [[ "$BRANCH" == "master" ]]; then
            PUSH_TAGS="${PUSH_TAGS},latest"
          fi

          if [[ "$BRANCH" == v* ]]; then
            VERSION="${BRANCH#v}"
            PUSH_TAGS="${PUSH_TAGS},${VERSION}"
            DEPLOY_TAG="${VERSION}"
          fi

          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "push_tags=${PUSH_TAGS}" >> "$GITHUB_OUTPUT"
          echo "deploy_tag=${DEPLOY_TAG}" >> "$GITHUB_OUTPUT"

          echo "Branch: $BRANCH"
          echo "Short SHA: $SHORT_SHA"
          echo "Push tags: $PUSH_TAGS"
          echo "Deploy tag: $DEPLOY_TAG"

      - name: Build local image via .NET (no Dockerfile)
        shell: bash
        run: |
          set -euo pipefail

          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"
          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"

          dotnet publish "${{ env.BOOTSTRAPPER_CSPROJ }}" -c Release \
            /t:PublishContainer \
            -p:ContainerRepository="$BOOTSTRAPPER_FULL_REPO" \
            -p:ContainerImageTag="$LOCAL_TAG"

          echo "Built: $BOOTSTRAPPER_FULL_REPO:$LOCAL_TAG"
          docker images | head -n 30

      - name: Tag + push to GHCR
        shell: bash
        run: |
          set -euo pipefail

          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"
          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"
          SOURCE_IMAGE="${BOOTSTRAPPER_FULL_REPO}:${LOCAL_TAG}"

          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.push_tags }}"

          for t in "${TAGS[@]}"; do
            REMOTE_IMAGE="${BOOTSTRAPPER_FULL_REPO}:${t}"
            echo "Pushing ${REMOTE_IMAGE}"
            docker tag "${SOURCE_IMAGE}" "${REMOTE_IMAGE}"
            docker push "${REMOTE_IMAGE}"
          done

      - name: Aspire publish (generate compose + Dockerfiles)
        shell: bash
        run: |
          set -euo pipefail
      
          OUT="./artifacts/aspire-publish"
          mkdir -p "$OUT"
      
          aspire publish "${APPHOST}" -o "$OUT"
      
          echo "Publish output tree:"
          find "$OUT" -maxdepth 4 -type f -print


      - name: Build local web image required by frontend-server.Dockerfile
        shell: bash
        run: |
          set -euo pipefail
      
          OUT="./artifacts/aspire-publish"
      
          FRONTEND_DOCKERFILE="$(find "$OUT" -maxdepth 5 -name 'frontend-server.Dockerfile' -print -quit)"
          if [[ -z "${FRONTEND_DOCKERFILE}" ]]; then
            echo "frontend-server.Dockerfile not found under $OUT"
            find "$OUT" -maxdepth 5 -type f -name '*.Dockerfile' -print || true
            exit 1
          fi
      
          WEB_IMAGENAME="$(grep -E '^ARG WEB_IMAGENAME=' "$FRONTEND_DOCKERFILE" | head -n 1 | cut -d= -f2)"
          echo "WEB_IMAGENAME from frontend-server.Dockerfile: $WEB_IMAGENAME"
      
          # Find a Dockerfile that looks like the Vite build image (contains "FROM node")
          WEB_DOCKERFILE="$(grep -RIl --include='*.Dockerfile' '^FROM node' "$OUT" | head -n 1 || true)"
          if [[ -z "${WEB_DOCKERFILE}" ]]; then
            echo "Could not find a web Dockerfile (no Dockerfile with 'FROM node' under $OUT). Dockerfiles found:"
            find "$OUT" -maxdepth 5 -type f -name '*.Dockerfile' -print || true
            exit 1
          fi
      
          echo "Building local web image from: $WEB_DOCKERFILE"
          docker build -f "$WEB_DOCKERFILE" -t "$WEB_IMAGENAME" "$(dirname "$WEB_DOCKERFILE")"
      
          echo "Local web image now exists:"
          docker images "$WEB_IMAGENAME" || true

      - name: Build + push frontend-server image (YARP + static files)
        shell: bash
        run: |
          set -euo pipefail

          # Generate publish artifacts to get frontend-server.Dockerfile and the local "web" image.
          rm -rf ./artifacts/aspire-publish
          mkdir -p ./artifacts/aspire-publish

          aspire publish "${{ env.APPHOST }}" -o ./artifacts/aspire-publish

          DOCKERFILE="$(find ./artifacts/aspire-publish -type f -name "frontend-server.Dockerfile" | head -n 1 || true)"
          if [ -z "$DOCKERFILE" ]; then
            echo "❌ Could not find frontend-server.Dockerfile in Aspire publish output"
            find ./artifacts/aspire-publish -maxdepth 3 -type f -print || true
            exit 1
          fi

          # frontend-server.Dockerfile contains the default WEB_IMAGENAME we need to copy /app/dist from.
          WEB_IMAGE="$(grep -E '^ARG WEB_IMAGENAME=' "$DOCKERFILE" | head -n 1 | cut -d= -f2- | tr -d '\r' || true)"
          if [ -z "$WEB_IMAGE" ]; then
            echo "❌ Could not extract WEB_IMAGENAME from $DOCKERFILE"
            head -n 20 "$DOCKERFILE" || true
            exit 1
          fi

          echo "Using web image stage: $WEB_IMAGE"
          docker image inspect "$WEB_IMAGE" >/dev/null

          FRONTEND_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.FRONTEND_IMAGE_REPO }}"
          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"

          DOCKER_DIR="$(dirname "$DOCKERFILE")"

          # Build local image
          docker build             -f "$DOCKERFILE"             --build-arg WEB_IMAGENAME="$WEB_IMAGE"             -t "${FRONTEND_FULL_REPO}:${LOCAL_TAG}"             "$DOCKER_DIR"

          echo "Built: ${FRONTEND_FULL_REPO}:${LOCAL_TAG}"

          # Tag + push
          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.push_tags }}"
          for t in "${TAGS[@]}"; do
            REMOTE_IMAGE="${FRONTEND_FULL_REPO}:${t}"
            echo "Pushing ${REMOTE_IMAGE}"
            docker tag "${FRONTEND_FULL_REPO}:${LOCAL_TAG}" "${REMOTE_IMAGE}"
            docker push "${REMOTE_IMAGE}"
          done

      - name: Write deploy info artifact
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ./artifacts

          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"
          FRONTEND_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.FRONTEND_IMAGE_REPO }}"
          DEPLOY_TAG="${{ steps.meta.outputs.deploy_tag }}"

          # Put whatever else you want Aspire to consume here (port, etc.)
          PORT="8080"

          cat > ./artifacts/deploy-info.env <<EOF
          BOOTSTRAPPER_FULL_REPO=${BOOTSTRAPPER_FULL_REPO}
          FRONTEND_FULL_REPO=${FRONTEND_FULL_REPO}
          DEPLOY_TAG=${DEPLOY_TAG}
          PORT=${PORT}
          EOF

          echo "deploy-info.env:"
          cat ./artifacts/deploy-info.env

      - name: Upload deploy info
        uses: actions/upload-artifact@v4
        with:
          name: deploy-info
          path: ./artifacts/deploy-info.env
          if-no-files-found: error
