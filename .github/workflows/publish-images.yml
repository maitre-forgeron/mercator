name: Publish Images

on:
  # For master: publish only after CI succeeded (keeps your "only publish verified code" guarantee)
  workflow_run:
    workflows: ["CI"]
    types: [completed]

  # For version tags: run directly on tag push (because workflow_run.head_branch is unreliable/empty for tags)
  push:
    tags:
      - "v*"

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  publish:
    if: >
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'master')
      ||
      (github.event_name == 'push' &&
       startsWith(github.ref, 'refs/tags/v'))
    runs-on: ubuntu-latest

    env:
      REGISTRY: ghcr.io
      OWNER: ${{ github.repository_owner }}
      IMAGE_REPO: mercator-bootstrapper
      FRONTEND_IMAGE_REPO: mercator-frontend-server
      APPHOST: src/Mercator.AppHost/Mercator.AppHost.csproj
      BOOTSTRAPPER_CSPROJ: src/Mercator.Bootstrapper/Mercator.Bootstrapper.csproj

      PUBLISH_OUT: ./artifacts/aspire-publish
      WEB_DIR: src/web

    steps:
      - name: Resolve ref + sha (workflow_run vs tag push)
        id: ref
        shell: bash
        env:
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "sha=${{ github.event.workflow_run.head_sha }}" >> "$GITHUB_OUTPUT"
            echo "ref=" >> "$GITHUB_OUTPUT"                 # checkout by sha
            echo "ref_name=$HEAD_BRANCH" >> "$GITHUB_OUTPUT"
            echo "mode=master" >> "$GITHUB_OUTPUT"
          else
            # push to tag: github.sha is the tag commit SHA, github.ref_name is the tag name (e.g. v1.2.3)
            echo "sha=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "ref=${{ github.ref }}" >> "$GITHUB_OUTPUT"
            echo "ref_name=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
            echo "mode=tag" >> "$GITHUB_OUTPUT"
          fi

          echo "Event: ${{ github.event_name }}"
          echo "Mode: $(cat $GITHUB_OUTPUT | grep '^mode=' | cut -d= -f2)"
          echo "RefName: $(cat $GITHUB_OUTPUT | grep '^ref_name=' | cut -d= -f2)"
          echo "SHA: $(cat $GITHUB_OUTPUT | grep '^sha=' | cut -d= -f2)"

      - name: Checkout (exact commit)
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ref.outputs.sha }}

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x
          include-prerelease: true

      - name: Install Aspire CLI
        run: dotnet tool install --global Aspire.Cli

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: meta
        shell: bash
        env:
          REF_SHA: ${{ steps.ref.outputs.sha }}
          REF_NAME: ${{ steps.ref.outputs.ref_name }}
          REF_MODE: ${{ steps.ref.outputs.mode }}
        run: |
          set -euo pipefail
          SHA="$REF_SHA"
          SHORT_SHA="${SHA:0:7}"
          NAME="$REF_NAME"
          MODE="$REF_MODE"

          PUSH_TAGS="sha-${SHORT_SHA}"
          DEPLOY_TAG="sha-${SHORT_SHA}"

          if [[ "$MODE" == "master" ]]; then
            PUSH_TAGS="${PUSH_TAGS},latest"
          fi

          # tag push: NAME is like "v1.2.3"
          if [[ "$MODE" == "tag" && "$NAME" == v* ]]; then
            VERSION="${NAME#v}"
            PUSH_TAGS="${PUSH_TAGS},${VERSION}"
            DEPLOY_TAG="${VERSION}"
          fi

          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "push_tags=${PUSH_TAGS}" >> "$GITHUB_OUTPUT"
          echo "deploy_tag=${DEPLOY_TAG}" >> "$GITHUB_OUTPUT"

          echo "Mode: $MODE"
          echo "Name: $NAME"
          echo "Short SHA: $SHORT_SHA"
          echo "Push tags: $PUSH_TAGS"
          echo "Deploy tag: $DEPLOY_TAG"

      # ---------------------------
      # Backend (bootstrapper) image
      # ---------------------------
      - name: Build local bootstrapper image via .NET (PublishContainer)
        shell: bash
        run: |
          set -euo pipefail

          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"
          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"

          dotnet publish "${{ env.BOOTSTRAPPER_CSPROJ }}" -c Release \
            /t:PublishContainer \
            -p:ContainerRepository="$BOOTSTRAPPER_FULL_REPO" \
            -p:ContainerImageTag="$LOCAL_TAG"

          echo "Built: $BOOTSTRAPPER_FULL_REPO:$LOCAL_TAG"

      - name: Tag + push bootstrapper to GHCR
        shell: bash
        run: |
          set -euo pipefail

          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"
          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"
          SOURCE_IMAGE="${BOOTSTRAPPER_FULL_REPO}:${LOCAL_TAG}"

          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.push_tags }}"
          for t in "${TAGS[@]}"; do
            REMOTE_IMAGE="${BOOTSTRAPPER_FULL_REPO}:${t}"
            echo "Pushing ${REMOTE_IMAGE}"
            docker tag "${SOURCE_IMAGE}" "${REMOTE_IMAGE}"
            docker push "${REMOTE_IMAGE}"
          done

      # ---------------------------
      # Aspire publish (generates frontend-server.Dockerfile)
      # ---------------------------
      - name: Aspire publish (generate compose + Dockerfiles)
        shell: bash
        run: |
          set -euo pipefail

          rm -rf "${PUBLISH_OUT}"
          mkdir -p "${PUBLISH_OUT}"

          aspire publish "${APPHOST}" -o "${PUBLISH_OUT}"

          echo "Publish output files:"
          find "${PUBLISH_OUT}" -maxdepth 5 -type f -print

      # ---------------------------
      # Frontend: build local web:<hash> stage image expected by frontend-server.Dockerfile
      # ---------------------------
      - name: Build local web stage image required by frontend-server.Dockerfile
        shell: bash
        run: |
          set -euo pipefail

          FRONTEND_DOCKERFILE="$(find "${PUBLISH_OUT}" -maxdepth 5 -name 'frontend-server.Dockerfile' -print -quit)"
          if [[ -z "${FRONTEND_DOCKERFILE}" ]]; then
            echo "❌ frontend-server.Dockerfile not found under ${PUBLISH_OUT}"
            exit 1
          fi

          WEB_IMAGENAME="$(grep -E '^ARG WEB_IMAGENAME=' "${FRONTEND_DOCKERFILE}" | head -n 1 | cut -d= -f2- | tr -d '\r')"
          if [[ -z "${WEB_IMAGENAME}" ]]; then
            echo "❌ Could not extract WEB_IMAGENAME from ${FRONTEND_DOCKERFILE}"
            head -n 20 "${FRONTEND_DOCKERFILE}" || true
            exit 1
          fi

          echo "WEB_IMAGENAME expected by YARP Dockerfile: ${WEB_IMAGENAME}"

          cat > /tmp/web.stage.Dockerfile <<'EOF'
          FROM node:20-alpine
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci
          COPY . .
          RUN npm run build
          EOF

          echo "Building local web image from ${WEB_DIR} ..."
          docker build -f /tmp/web.stage.Dockerfile -t "${WEB_IMAGENAME}" "${WEB_DIR}"
          docker image inspect "${WEB_IMAGENAME}" >/dev/null
          echo "✅ Local web stage image exists: ${WEB_IMAGENAME}"

      # ---------------------------
      # Frontend-server: build & push YARP image that contains static files
      # ---------------------------
      - name: Build + push frontend-server image (YARP + static files)
        shell: bash
        run: |
          set -euo pipefail

          DOCKERFILE="$(find "${PUBLISH_OUT}" -maxdepth 5 -name 'frontend-server.Dockerfile' -print -quit)"
          if [[ -z "${DOCKERFILE}" ]]; then
            echo "❌ Could not find frontend-server.Dockerfile in ${PUBLISH_OUT}"
            exit 1
          fi

          WEB_IMAGE="$(grep -E '^ARG WEB_IMAGENAME=' "${DOCKERFILE}" | head -n 1 | cut -d= -f2- | tr -d '\r')"
          docker image inspect "${WEB_IMAGE}" >/dev/null

          FRONTEND_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.FRONTEND_IMAGE_REPO }}"
          LOCAL_TAG="local-${{ steps.meta.outputs.short_sha }}"
          DOCKER_DIR="$(dirname "${DOCKERFILE}")"

          docker build \
            -f "${DOCKERFILE}" \
            --build-arg WEB_IMAGENAME="${WEB_IMAGE}" \
            -t "${FRONTEND_FULL_REPO}:${LOCAL_TAG}" \
            "${DOCKER_DIR}"

          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.push_tags }}"
          for t in "${TAGS[@]}"; do
            REMOTE_IMAGE="${FRONTEND_FULL_REPO}:${t}"
            echo "Pushing ${REMOTE_IMAGE}"
            docker tag "${FRONTEND_FULL_REPO}:${LOCAL_TAG}" "${REMOTE_IMAGE}"
            docker push "${REMOTE_IMAGE}"
          done

      - name: Write deploy info artifact
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ./artifacts

          BOOTSTRAPPER_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.IMAGE_REPO }}"
          FRONTEND_FULL_REPO="${{ env.REGISTRY }}/${{ env.OWNER }}/${{ env.FRONTEND_IMAGE_REPO }}"
          DEPLOY_TAG="${{ steps.meta.outputs.deploy_tag }}"
          PORT="8080"

          cat > ./artifacts/deploy-info.env <<EOF
          BOOTSTRAPPER_FULL_REPO=${BOOTSTRAPPER_FULL_REPO}
          FRONTEND_FULL_REPO=${FRONTEND_FULL_REPO}
          DEPLOY_TAG=${DEPLOY_TAG}
          PORT=${PORT}
          EOF

          cat ./artifacts/deploy-info.env

      - name: Upload deploy info
        uses: actions/upload-artifact@v4
        with:
          name: deploy-info
          path: ./artifacts/deploy-info.env
          if-no-files-found: error
